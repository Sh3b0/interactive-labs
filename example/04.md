# Digital Certificates

We *assumed* that Alice knows Bob's public key, but how can she be sure that the key indeed belongs to Bob.

- For all we know, Eve can act as Bob and supply her public key to Alice.
- Eve can also act as Alice on Bob's side, effectively carrying out a **Man-in-the-Middle** attack.

## Idea

A digital certificate is a file with some attributes and values. It proves that a certain entity owns a certain public key.

It's Issued by a certain Certification Authority (CA). The CA also has `CA_publicKey` and `CA_privateKey`

1. Bob sends his publicKey to the Alice along with a proof: the certificate that verifies that his ownership of public key.

   ```
   certificate = encrypt(publicKey, CA_privateKey)
   ```

2. Everyone knows CA_publicKey, Alice can then verify whether

   ```
   publicKey == decrypt(certificate, CA_publicKey)
   ```

3. But how can Alice trust a given `CA_publicKey`? A chain of trust has to be followed until reaching a root CA (trusted by default in OS or browser).

   ```terminal:execute
   prefix: Command
   title: Click to execute in highlighted terminal
   command: ls /usr/share/ca-certificates/mozilla
   ```

## Exercise 4

1. Run a local HTTP server (e.g., Apache or Nginx)
2. Use `mkcert`, `openssl` or any other tool to generate a self-signed certificate
3. Configure your server to present the certificate
4. Show in the CLI (e.g., with `curl`) how HTTPS access was acheived.

## Exercise 5 (Bonus)

1. Run any sample web app on a cloud instance.
2. Assign temporary domain using DDNS (e.g., using [duckdns.org](https://duckdns.org))
3. Configure Let's Encrypt for a trusted certificate (e.g., using [Caddy](https://github.com/caddyserver/caddy))
4. Run the infrastructure with a single `docker compose up`
